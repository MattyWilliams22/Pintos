            +--------------------------+
            |          OS 211          |
            |  TASK 3: VIRTUAL MEMORY  |
            |      DESIGN DOCUMENT     |
            +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Matty Williams          mw2122@ic.ac.uk
Kritik Pant             kp1222@ic.ac.uk
Shivam Subudhi          ss4522@ic.ac.uk
Atheepan Chandrakumaran ac4322@ic.ac.uk

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, or notes for the
>> markers, please give them here.

None

>> Please cite any offline or online sources you consulted while preparing your 
>> submission, other than the Pintos documentation, course text, lecture notes 
>> and course staff.

None

            PAGE TABLE/FRAME MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: (2 marks)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> supplemental page table and frame table. 
>> Identify the purpose of each in roughly 25 words.


enum page_type
{
  FILE,
  FRAME,
  ZERO
};
The type of a page.

/* One page for the supplemental page table. */
struct page
{
  struct hash_elem elem;
  void *key; // user virtual address
  uint8_t *kernel_addr; // kernel virtual address
  bool writable;
  off_t offset;
  size_t read_bytes;
  size_t zero_bytes;
  struct file *file;
  enum page_type type;
};

/* One frame to be stored in the frame table. */
struct frame {
  struct hash_elem elem;
  void *page_phys_addr;
  void *page_user_addr;
  // struct thread* owner;
};

/* The frame table. */
struct hash frame_table;

/* Lock used to control access to the frame table. */
struct lock frame_table_lock;


---- ALGORITHMS ----

>> A2: (2 marks) 
>> Describe your code for finding the frame (if any) or other location that 
>> contains the data of a given page.

>> A3: (2 marks)
>> How have you implemented sharing of read only pages?

---- SYNCHRONIZATION ----

>> A4: (2 marks) 
>> When two user processes both need a new frame at the same time, how are 
>> races avoided? 
>> You should consider both when there are and are not free frames 
>> available in memory.

We have used a lock called the frame_table_lock to avoid race conditions.
Before accessing the frame table, we always acquire the lock and then release it
once a thread is done reading/modifying the table.

---- RATIONALE ----

>> A5: (2 marks)
>> Why did you choose the data structure(s) that you did for representing the
>> supplemental page table and frame table?

We chose to use hashes to represent both the page and frame tables. 
This improves access speeds as you do bot have to iterate through a long list to
find a page/frame (taking O(n) time), instead a hash is calculated and used to 
find the page/frame (taking O(1) time).


               PAGING TO AND FROM DISK
               =======================

---- ALGORITHMS ----

>> B2: (2 marks)
>> When a frame is required but none is free, some frame must be evicted.
>> Describe your code for choosing a frame to evict.



>> B3: (2 marks)
>> When a process P obtains a frame that was previously used by a process Q,
>> how do you adjust the page directory of process Q (and any other data 
>> structures) to reflect the frame Q no longer has?



---- SYNCHRONIZATION ----

>> B4: (2 marks)
>> Explain how your synchronization design prevents deadlock.  
>> (You may want to refer to the necessary conditions for deadlock.)

Deadlock occurs when two threads are each trying to acquire locks that the other
thread already holds. In our code we always use the same order when acquiring 
locks. This means that deadlock does not occur.

>> B5: (2 marks)
>> A page fault in process P can cause another process Q's frame to be evicted.
>> How do you ensure that Q cannot access or modify the page during the 
>> eviction process?

>> B6: (2 marks)
>> A page fault in process P can cause another process Q's frame to be evicted.
>> How do you avoid a race between P evicting Q's frame and Q faulting the page
>> back in?

>> B7: (2 marks)
>> Explain how you handle access to user pages that are not present when a
>> system call is made.

---- RATIONALE ----

>> B8: (2 marks)
>> There is an obvious trade-off between parallelism and the complexity of your
>> synchronisation methods. 
>> Explain where your design falls along this continuum and why you chose to 
>> design it this way.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: (2 marks)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> file mapping table.  
>> Identify the purpose of each in roughly 25 words.

/* Type used for uniquely identifying mapped_files. */
typedef int mapid_t;

/* A mapped file. */
struct mapped_file
{
    mapid_t mapid;          /* Unique id of mapped file. */
    struct file *file;      /* File that is being mapped. */
    void *addr;             /* Address of file in user space. */
    size_t page_count;      /* Number of pages in the file. */
    struct list_elem elem;  /* Used for adding to thread->mapped_files list. */
};

---- ALGORITHMS ----

>> C2: (3 marks)
>> Explain how you determine whether a new file mapping overlaps with any 
>> existing segment and how you handle such a case.

---- RATIONALE ----

>> C3: (1 mark)
>> Mappings created with "mmap" have similar semantics to those of data 
>> demand-paged from executables. 
>> How does your code-base take advantage of this?
